***********《朱有鹏老师单片机完全学习系列课程》 ***********
*********** 第4季：uCOS2和uCOS3在STM32F3和F4平台源码全解 **
*********** 4.5.uCOS2的events事件源码分析     	***********

--------------------------------------------------------
本课程由朱有鹏物联网大讲堂录制并拥有完整版权，翻录必究
--------------------------------------------------------
第一部分、章节目录
4.5.1.互斥锁和信号量
4.5.2.ucos2的mutex互斥锁源码分析1
4.5.3.ucos2的mutex互斥锁源码分析2
4.5.4.ucos2的优先级翻转问题1
4.5.5.OSMutexPend函数详解1
4.5.6.OSMutexPend函数详解2
4.5.7.OSMutexPost函数详解
4.5.8.ucos2的semaphore信号量源码解析
4.5.9.ucos2的旗标FLAG源码解析1
4.5.10.ucos2的旗标FLAG源码解析2
4.5.11.ucos2的旗标FLAG源码解析3
4.5.12.ucos2的旗标FLAG源码解析4	
4.5.13.ucos2的旗标FLAG源码解析5
4.5.14.ucos2的MBOX源码解析	
4.5.15.ucos2的Q源码解析1	
4.5.16.ucos2的Q源码解析2	
4.5.17.ucos2的Q源码解析3

	

第二部分、章节介绍
4.5.1.互斥锁和信号量
	本节从操作系统原理角度来分析互斥锁和信号量这两个概念，为后面分析源码打好基础。
4.5.2.ucos2的mutex互斥锁源码分析1
	本节开始分析ucos2的mutex源码，主要是非阻塞方式的mutex申请函数OSMutexAccept。
4.5.3.ucos2的mutex互斥锁源码分析2
	本节继续分析ucos2的mutex源码，主要是OSMutexDel函数，分析mutex删除的细节。
4.5.4.ucos2的优先级翻转问题1
	本节从理论角度分析下什么是操作系统的优先级反转问题，同时提出了2种解决优先级反转的理论。同时讲了ucos2解决优先级反转问题的策略，为后面课程打基础。
4.5.5.OSMutexPend函数详解1
	本节开始分析ucos2的OSMutexPend函数，该函数中实际遇到了优先级反转的问题并用代码实现了解决方案。
4.5.6.OSMutexPend函数详解2
	本节接上节继续分析ucos2的OSMutexPend函数，该函数中实际遇到了优先级反转的问题并用代码实现了解决方案。
4.5.7.OSMutexPost函数详解
	本节详解OSMutexPost函数，重点是信号量释放后对排队等待任务的唤醒和标记工作。
4.5.8.ucos2的semaphore信号量源码解析
	本节讲解信号量的源码分析，有前面几节mutex的基础信号量的代码分析起来非常容易。
4.5.9.ucos2的旗标FLAG源码解析1
	本节开始讲解ucos2的旗标FLAG，首先从原理性上讲述FLAG的工作原理和主要用途。
4.5.10.ucos2的旗标FLAG源码解析2
	本节主要讲解FLAG的非阻塞版本获取函数OSFlagAccept，并同时对比FLAG和EVENT的处理差异点。
4.5.11.ucos2的旗标FLAG源码解析3
	本节主要讲解FLAG的创建和删除函数OSFlagCreate和OSFlagDel。
4.5.12.ucos2的旗标FLAG源码解析4	
	本节主要讲解FLAG的阻塞版本的check函数OSFlagPend。
4.5.13.ucos2的旗标FLAG源码解析5
	本节完成FLAG源码的分析，主要是剩余的几个函数了。
4.5.14.ucos2的MBOX源码解析	
	本节讲解ucos2的mailbox源码，因为有前面2个event的铺垫所以1节课就讲完了。
4.5.15.ucos2的Q源码解析1	
	本节开始讲解ucos2的Queen队列，首先从数据结构角度系统讲了队列这种数据结构的特征。
4.5.16.ucos2的Q源码解析2
	本节继续讲解queen，主要分析了OSQAccept和OSQCreate这2个函数。
4.5.17.ucos2的Q源码解析3
	本节继续讲解queen，分析了剩余的所有接口，因为和其他event非常类似所以很快就看完了。
	
	
	
第三部分、随堂记录
4.5.1.互斥锁和信号量
4.5.1.1、互斥锁
(1)互斥访问、资源保护
(2)任务同步
(3)多个任务的等待与唤醒排队机制
4.5.1.2、信号量
(1)多资源的互斥访问
(2)图书馆借书的案例


4.5.2_3.ucos2的mutex互斥锁源码分析1_2
(1)pip应该小于当前任务的优先级（OSTCBCur->OSTCBPrio）才是对的。
(2)OS_EVENT.OSEventCnt元素非常重要，它是一个INT16U的值，低8位用来存储0xff（表示该互斥锁还没被某个任务获取）或者是获取了该互斥锁的任务的优先级。高8位pip用来保存用于减少优先级反转的优先级数字。
(3)OSMutexCreate函数就是从OSEventTbl中通过OSEventFreeList来找到第一个空闲的格子，把这个各自申请到然后填充作为申请的Mutex返回即可。同时记得把OSEventFreeList指向下一个格子，以备下一次调用OSMutexCreate时还能找到下一个。


4.5.4.ucos2的优先级翻转问题1
参考：http://www.docin.com/p-99652337.html
4.5.4.1、ucos2的优先级
4.5.4.2、什么是优先级翻转
4.5.4.3、如何解决优先级翻转
(1)优先级天花板
(2)优先级继承
4.5.4.4、ucos2如何解决优先级反转


4.5.5_6.OSMutexPend函数详解1_2
当前任务A和事先已经拿到mutex的任务B的策略是：
(1)如果优先级方面A比B高，就有可能有优先级反转，所以A就要考虑临时性提升B的优先级。
(2)如果B本来就是就绪态，那么A提升完B的优先级到pip之后仍然让B为就绪态，这样在A后面OS_Sched后就会自动调度轮到（也许有个任务的优先级比pip还高，那得他先运行）B先运行。
(3)如果B本来是非就绪态，那么A提升完B的优先级到pip之后仍然让B为非就绪态，这样A后面OS_Sched后B不能被调度的，会调度C、D、E等，这是个问题。


4.5.7.OSMutexPost函数详解


4.5.8.ucos2的semaphore信号量源码解析


4.5.9_10.ucos2的旗标FLAG源码解析1_2
(1)FLAG实质是INT16U类型的变量，用法是16个bit位每个bit位代表一个特定含义（程序自己定义的），特定位的0和1分别代表不同意义，任务可以通过给bit位置1或者0来设置flag，其他任务可以通过读取这个bit位来获取flag的状态，从而决定任务的运行轨迹。
(2)flag的主要用途是做任务之间的同步。

OS_FLAG_WAIT_CLR_ALL	表示我们等待的所有bit都变成0就返回true，否则false
OS_FLAG_WAIT_CLR_ANY	表示我们等待的所有bit中只要有1个为0就返回true，否则false
OS_FLAG_WAIT_SET_ALL	表示我们等待的所有bit都变成1就返回ture，否则flase
OS_FLAG_WAIT_SET_ANY	表示我们等待的所有bit中只要有1个为1就返回true，否则false


4.5.11_12.ucos2的旗标FLAG源码解析3_4


4.5.13.ucos2的旗标FLAG源码解析5


4.5.14.ucos2的MBOX源码解析


4.5.15_16.ucos2的Q源码解析1_2
4.5.15.1、常用的数据结构
(1)数组
(2)结构体
(3)链表
(4)栈			FILO first in last out		临时分配使用内存并回收
(5)队列			FIFO first in first out		缓冲、速率匹配，循环使用


4.5.17.ucos2的Q源码解析3























